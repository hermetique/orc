//
// GenerateSiteClasses.scala -- Generator program for Orc Site base classes.
// Project OrcScala
//
// Created by amp on July, 2018.
//
// Copyright (c) 2018 The University of Texas at Austin. All rights reserved.
//
// Use and redistribution of this file is governed by the license terms in
// the LICENSE file found in the project's top-level directory and also found at
// URL: http://orc.csres.utexas.edu/license.shtml .
//
package orc.values.sites

import java.io.FileWriter

/** A Scala program which generates Sites{n}Util.scala files.
  *
  * This program is NOT run during the build. Instead, if you need to update the
  * generated files you should change this program, run it, move the files into
  * this package, then commit both this and the generated files.
  *
  * If, for whatever reason, you need to run this program without a complete build
  * of Orc (this should never happen since the Sites{n}Util.scala files are included
  * in the repo), you can run something similar to this:
  *
  * >>> java -cp scala-compiler-2.12.4.jar:scala-library-2.12.4.jar:scala-reflect-2.12.4.jar scala.tools.nsc.Main -usejavacp OrcScala/src/orc/values/sites/GenerateSiteClasses.scala
  * >>> java -cp scala-compiler-2.12.4.jar:scala-library-2.12.4.jar:scala-reflect-2.12.4.jar:. orc.values.sites.GenerateSiteClasses
  * >>> mv Sites*.scala OrcScala/src/orc/values/sites/
  *
  * For this reason, GenerateSiteClasses.scala should not use any other classes in Orc.
  */
object GenerateSiteClasses {
  def main(args: Array[String]): Unit = {
    val maxN = 3
    for (n <- 0 to maxN) {
      val out = new FileWriter(s"Sites${n}Util.scala")
      out.append(s"""
//
// Sites${n}Util.scala -- Scala traits and classes for ${n}-ary sites
// Project OrcScala
//
// AUTOGENERATED by orc.values.sites.GenerateSiteClasses
// Do not edit!!!
//
// Copyright (c) 2018 The University of Texas at Austin. All rights reserved.
//
// Use and redistribution of this file is governed by the license terms in
// the LICENSE file found in the project's top-level directory and also found at
// URL: http://orc.csres.utexas.edu/license.shtml .
//

package orc.values.sites

import scala.reflect.ClassTag

import orc.VirtualCallContext
import orc.SiteResponseSet
import orc.Invoker
import orc.OrcRuntime
import orc.DirectInvoker
import orc.error.runtime.HaltException
import orc.error.runtime.ArityMismatchException
import orc.error.runtime.ArgumentTypeMismatchException

import InvocationBehaviorUtilities._

""")
      out.append(SiteNUtils(n, Raw))
      out.append("\n\n")
      out.append(SiteNUtils(n, Partial))
      out.append("\n\n")
      out.append(SiteNUtils(n, Total))
      out.append("\n\n")
      out.append(HasGetInvokerN(n, Raw))
      out.append("\n\n")
      out.append(HasGetInvokerN(n, Total))
      out.append("\n\n")
      out.close()
    }
  }

  sealed abstract class Config(
      val prefix: String,
      val isDirect: Boolean,
      val hasCtxArg: Boolean,
      val invokeReturn: String) {
    def callImpl(implArguments: String): String
  }

  case object Raw extends Config("", false, true, "SiteResponseSet") {
    def callImpl(implArguments: String): String = {
      s"""
      orc.run.StopWatches.implementation {
        impl($implArguments)
      }
      """.trim()
    }
  }

  case object Total extends Config("Total", true, false, "Any") {
    def callImpl(implArguments: String): String = {
      s"""
      try {
        orc.run.StopWatches.implementation {
          impl($implArguments).asInstanceOf[AnyRef]
        }
      } catch {
        case e: Exception =>
          throw new HaltException(e)
      }
      """.trim()
    }
  }

  case object Partial extends Config("Partial", true, false, "Option[Any]") {
    def callImpl(implArguments: String): String = {
      s"""
      (try {
        orc.run.StopWatches.implementation {
          impl($implArguments)
        }
      } catch {
        case e: Exception =>
          throw new HaltException(e)
      }) match {
        case Some(v) => v.asInstanceOf[AnyRef]
        case None => throw new HaltException()
      }
      """.trim()
    }
  }

  def SiteNUtils(n: Int, cfg: Config) = {
    import cfg._

    def argumentIterator = 0 until n
    def bracketed(f: Int => String) = {
      if (n > 0)
        argumentIterator.map(f).mkString("[", ", ", "]")
      else
        ""
    }
    def free(f: Int => String) = {
      argumentIterator.map(f).mkString(", ")
    }
    def leadingcomma(f: Int => String) = {
      if (n > 0)
        argumentIterator.map(f).mkString(", ", ", ", "")
      else
        ""
    }

    val invokerArgTypes = leadingcomma(i => s"AA$i")

    def when(b: Boolean, s: String) = if (b) s else ""

    s"""
trait ${prefix}Site$n extends ${prefix}Site with SpecificArity {
  val arity = $n
}

abstract class ${prefix}Site${n}Base${bracketed(i => s"A$i : ClassTag")} extends HasGet${when(isDirect, "Direct")}Invoker${n}${bracketed(i => s"A$i")} with ${prefix}Site${n} {
  /** Create an invoker which works for any instance of this Site class.
    *
    * exampleTarget should be this, examplesArguments should be the arguments
    * with the correct types for this invoker.
    */
  protected def invoker[T <: ${prefix}Site${n}Base${bracketed(i => s"A$i")}${leadingcomma(i => s"AA$i <: A$i")}]
        (exampleTarget: T${leadingcomma(i => s"example$i: AA$i")})
        (_impl: (${when(hasCtxArg, "VirtualCallContext, ")}T${invokerArgTypes}) => $invokeReturn): ${when(isDirect, "Direct")}Invoker = {
    new TargetClassAndArgumentClassSpecializedInvoker(exampleTarget, Array[Any](${free(i => s"example$i")}).asInstanceOf[Array[AnyRef]])
          with ${prefix}Site${n}Base.ImplInvoker[T${invokerArgTypes}] {
      val impl = _impl
    }
  }
}

object ${prefix}Site${n}Base {
  trait ImplInvoker[T${invokerArgTypes}] extends ${when(isDirect, "Direct")}Invoker {
    val impl: (${when(hasCtxArg, "VirtualCallContext, ")}T${invokerArgTypes}) => $invokeReturn

    def invoke${when(isDirect, "Direct")}(${when(hasCtxArg, "ctx: VirtualCallContext, ")}target: AnyRef, arguments: Array[AnyRef]): ${if(isDirect) "AnyRef" else "SiteResponseSet"} = {
      ${
        callImpl(s"${when(hasCtxArg, "ctx, ")}target.asInstanceOf[T]${leadingcomma(i => s"arguments($i).asInstanceOf[AA$i]")}")
      }
    }
  }
}

abstract class ${prefix}Site${n}Simple${bracketed(i => s"A$i : ClassTag")} extends ${prefix}Site${n}Base${bracketed(i => s"A$i")} {
  def eval(${when(hasCtxArg, "ctx: VirtualCallContext")}${when(hasCtxArg && n > 0, ", ")}${free(i => s"arg$i: A$i")}): $invokeReturn

  final def getInvoker(runtime: OrcRuntime${leadingcomma(i => s"arg$i: A$i")}) =
    invoker(this${leadingcomma(i => s"arg$i")}) { (${when(hasCtxArg, "ctx, ")}self${leadingcomma(i => s"arg$i")}) =>
      self.eval(${when(hasCtxArg, "ctx")}${when(hasCtxArg && n > 0, ", ")}${free(i => s"arg$i")})
    }
}
""".trim()
  }
  def HasGetInvokerN(n: Int, cfg: Config) = {
    import cfg._

    def argumentIterator = 0 until n
    def bracketed(f: Int => String) = {
      if (n > 0)
        argumentIterator.map(f).mkString("[", ", ", "]")
      else
        ""
    }
    def free(f: Int => String) = {
      argumentIterator.map(f).mkString(", ")
    }
    def leadingcomma(f: Int => String) = {
      if (n > 0)
        argumentIterator.map(f).mkString(", ", ", ", "")
      else
        ""
    }

    def when(b: Boolean, s: String) = if (b) s else ""

    def checkArgumentType(i: Int) = {
      s"""
 else if (!valueHasTypeByTag[A$i](args($i))) {
      new TargetClassAndArgumentClassSpecializedInvoker(this, args) with DirectInvoker {
        @throws[Throwable]
        def invokeDirect(target: AnyRef, arguments: Array[AnyRef]): AnyRef = {
          throw new ArgumentTypeMismatchException($i, argumentTypeStrings($i), if (args($i) != null) args($i).getClass().toString() else "null")
        }
      }
    }
        """.trim
    }

    s"""
abstract class HasGet${when(isDirect, "Direct")}Invoker${n}${bracketed(i => s"A$i : ClassTag")} {
  val argumentTypeStrings = Array(${free(i => s"implicitly[ClassTag[A$i]].runtimeClass.getSimpleName")})
  final def getInvoker(runtime: OrcRuntime, args: Array[AnyRef]): ${when(isDirect, "Direct")}Invoker = {
    if (args.length != ${n}) {
      new TargetClassAndArgumentClassSpecializedInvoker(this, args) with DirectInvoker {
        @throws[Throwable]
        def invokeDirect(target: AnyRef, arguments: Array[AnyRef]): AnyRef = {
          throw new ArityMismatchException(${n}, args.size)
        }
      }
    } ${argumentIterator.map(checkArgumentType).mkString(" ")} else {
      getInvoker(runtime${leadingcomma(i => s"args($i).asInstanceOf[A$i]")})
    }
  }

  def getInvoker(runtime: OrcRuntime${leadingcomma(i => s"arg$i: A$i")}): ${when(isDirect, "Direct")}Invoker
}
    """.trim
  }

}
